<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neural_Reader | MagazineHub</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --brand-teal: #62D2B3;
            --brand-deep: #0a0a0f;
        }
        body { 
            font-family: 'JetBrains Mono', monospace; 
            background-color: var(--brand-deep); 
            color: #F9EBE0;
            overflow: hidden; margin: 0;
        }
        
        #viewerContainer {
            height: 110vh;
            overflow-y: auto;
            scroll-behavior: auto; /* Faster response than 'smooth' */
            padding-top: 50px;
            background: radial-gradient(circle at center, #161625 0%, #0a0a0f 100%);
        }

        .page-slot {
            margin: 20px auto;
            background: rgba(255,255,255,0.02);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transition: transform 0.4s ease;
            will-change: transform;
            position: relative;
        }

        /* Glitch effect on header */
        #readerHeader { 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            z-index: 100;
            border-bottom: 1px solid rgba(98, 210, 179, 0.2);
        }
        .header-hidden { transform: translateY(-100%); }

        #loaderCanvas {
            position: absolute;
            inset: 0;
            z-index: -1;
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <nav id="readerHeader" class="fixed top-0 w-full h-16 bg-black/80 backdrop-blur-md flex items-center justify-between px-6">
        <div id="topProgress" class="absolute bottom-0 left-0 h-[2px] bg-brand-teal transition-all duration-300 shadow-[0_0_10px_#62D2B3]"></div>
        <div class="flex items-center gap-6">
            <a href="index.html" class="text-brand-teal/60 hover:text-brand-teal">
                <span class="text-[10px] tracking-tighter">/EXIT_STILL</span>
            </a>
            <div>
                <h1 id="readerTitle" class="text-white font-bold text-xs uppercase tracking-widest truncate max-w-[200px]">Connecting...</h1>
                <p id="pageCountDisplay" class="text-brand-teal text-[9px] opacity-50">SYNCING_BIT_STREAM</p>
            </div>
        </div>
        <div id="readPercent" class="font-mono text-[10px] text-brand-teal">00%_SYNC</div>
    </nav>

    <div id="loadingScreen" class="fixed inset-0 bg-[#0a0a0f] z-[200] flex flex-col items-center justify-center">
        <canvas id="loaderCanvas"></canvas>
        <div class="text-center z-10">
            <div class="text-brand-teal font-bold text-4xl mb-2 tracking-tighter" id="percLabel">0%</div>
            <div class="text-[10px] tracking-[0.5em] text-white/40 uppercase" id="loadStatus">Downloading_Neural_Assets</div>
        </div>
    </div>

    <main id="viewerContainer">
        <div id="canvasContainer" class="pb-32"></div>
    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null;
        let lastScrollTop = 0;
        let downloadProgress = 0;
        const container = document.getElementById('canvasContainer');

        // --- Interactive Canvas Loader Logic ---
        const canvas = document.getElementById('loaderCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, columns;
        const fontSize = 14;
        const chars = "01010101010101010101010101010101";
        let drops = [];

        function initLoader() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            columns = Math.floor(width / fontSize);
            drops = Array(columns).fill(1);
        }

        function drawLoader() {
            ctx.fillStyle = "rgba(10, 10, 15, 0.1)";
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = "#62D2B3";
            ctx.font = fontSize + "px monospace";

            for (let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                // Speed up drops based on download progress
                const speed = 1 + (downloadProgress / 20);
                if (drops[i] * fontSize > height && Math.random() > 0.975) drops[i] = 0;
                drops[i] += speed;
            }
        }
        setInterval(drawLoader, 33);
        window.addEventListener('resize', initLoader);
        initLoader();

        // --- Core Reader Logic ---
        async function init() {
            const id = new URLSearchParams(window.location.search).get('id');
            if (!id) return window.location.href = 'index.html';

            try {
                const response = await fetch(`/api/magazines`);
                const mags = await response.json();
                const mag = mags.find(m => m.id == id);

                if (mag?.pdf_path) {
                    document.getElementById('readerTitle').innerText = mag.title;
                    loadMagazine(mag.pdf_path);
                }
            } catch (err) {
                document.getElementById('loadStatus').innerText = "FATAL_LINK_ERROR";
            }
        }

        async function loadMagazine(path) {
            const loadingTask = pdfjsLib.getDocument(path);

            loadingTask.onProgress = (p) => {
                downloadProgress = Math.round((p.loaded / (p.total || 1)) * 100);
                document.getElementById('percLabel').innerText = downloadProgress + "%";
                document.getElementById('topProgress').style.width = downloadProgress + "%";
            };

            pdfDoc = await loadingTask.promise;
            document.getElementById('pageCountDisplay').innerText = `ARCHIVE: ${pdfDoc.numPages}_NODES`;

            const firstPage = await pdfDoc.getPage(1);
            const viewport = firstPage.getViewport({ scale: 1 });
            const aspectRatio = viewport.height / viewport.width;

            // Pre-create slots for smooth scrolling
            for (let n = 1; n <= pdfDoc.numPages; n++) {
                const slot = document.createElement('div');
                slot.className = 'page-slot';
                slot.dataset.pagenum = n;
                const slotWidth = Math.min(window.innerWidth * 0.92, 1100);
                slot.style.width = `${slotWidth}px`;
                slot.style.height = `${slotWidth * aspectRatio}px`;
                container.appendChild(slot);
                pageObserver.observe(slot);
            }
            revealUI();
        }

        const pageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const num = parseInt(entry.target.dataset.pagenum);
                    renderPage(num, entry.target);
                    
                    // Update UI
                    const prog = Math.round((num / pdfDoc.numPages) * 100);
                    document.getElementById('readPercent').innerText = `${prog}%_SYNC`;
                    
                    // PREDICTIVE RENDERING: Load next and previous
                    if (num < pdfDoc.numPages) renderPage(num + 1);
                    if (num > 1) renderPage(num - 1);
                }
            });
        }, { rootMargin: '1000px', threshold: 0.01 });

        async function renderPage(num, target = null) {
            const el = target || document.querySelector(`[data-pagenum="${num}"]`);
            if (!el || el.classList.contains('rendered')) return;
            el.classList.add('rendered');

            const page = await pdfDoc.getPage(num);
            const scale = (window.innerWidth < 768) ? (window.innerWidth * 0.92) / page.getViewport({scale:1}).width : 1.8;
            const viewport = page.getViewport({ scale });
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            const dpr = window.devicePixelRatio || 1;

            canvas.width = viewport.width * dpr;
            canvas.height = viewport.height * dpr;
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            ctx.scale(dpr, dpr);

            await page.render({ canvasContext: ctx, viewport }).promise;
            
            el.innerHTML = '';
            canvas.style.opacity = '0';
            canvas.style.transition = 'opacity 0.5s ease-out';
            el.appendChild(canvas);
            
            requestAnimationFrame(() => canvas.style.opacity = '1');
            page.cleanup();
        }

        function revealUI() {
            anime({
                targets: '#loadingScreen',
                translateY: '-100%',
                duration: 800,
                easing: 'easeInOutExpo',
                complete: () => document.getElementById('loadingScreen').style.display = 'none'
            });
        }

        // Header auto-hide
        const viewer = document.getElementById('viewerContainer');
        viewer.addEventListener('scroll', () => {
            let st = viewer.scrollTop;
            document.getElementById('readerHeader').classList.toggle('header-hidden', st > lastScrollTop && st > 100);
            lastScrollTop = st;
        }, { passive: true });

        window.onload = init;
    </script>
</body>
</html>
